<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Spell Siege - Tower Defense Spelling Game</title>
  <meta name="description" content="A magical tower defense spelling game for kids">
  <meta name="theme-color" content="#1e1b4b">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üè∞</text></svg>">
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Quicksand:wght@500;600;700&display=swap" rel="stylesheet">
  
  <!-- React & Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            'title': ['Cinzel', 'serif'],
            'game': ['Quicksand', 'sans-serif'],
          },
          colors: {
            castle: {
              stone: '#4a5568',
              dark: '#2d3748',
              accent: '#ecc94b',
            },
            magic: {
              purple: '#9f7aea',
              blue: '#63b3ed',
              pink: '#f687b3',
              green: '#68d391',
            }
          },
          animation: {
            'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            'float': 'float 3s ease-in-out infinite',
            'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
            'spell-fire': 'spellFire 0.4s ease-out forwards',
            'enemy-spawn': 'enemySpawn 0.5s ease-out',
            'combo-pop': 'comboPop 0.3s ease-out',
          },
          keyframes: {
            float: {
              '0%, 100%': { transform: 'translateY(0)' },
              '50%': { transform: 'translateY(-10px)' },
            },
            shake: {
              '10%, 90%': { transform: 'translateX(-1px)' },
              '20%, 80%': { transform: 'translateX(2px)' },
              '30%, 50%, 70%': { transform: 'translateX(-4px)' },
              '40%, 60%': { transform: 'translateX(4px)' },
            },
            spellFire: {
              '0%': { transform: 'scale(0) rotate(0deg)', opacity: '1' },
              '50%': { transform: 'scale(1.5) rotate(180deg)', opacity: '0.8' },
              '100%': { transform: 'scale(0) rotate(360deg)', opacity: '0' },
            },
            enemySpawn: {
              '0%': { transform: 'scale(0) translateY(20px)', opacity: '0' },
              '100%': { transform: 'scale(1) translateY(0)', opacity: '1' },
            },
            comboPop: {
              '0%': { transform: 'scale(1)' },
              '50%': { transform: 'scale(1.3)' },
              '100%': { transform: 'scale(1)' },
            }
          }
        }
      }
    }
  </script>
  
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: 'Quicksand', sans-serif;
      -webkit-user-select: none;
      user-select: none;
    }
    
    /* Gradient background */
    .game-bg {
      background: linear-gradient(180deg, 
        #0f0c29 0%, 
        #302b63 40%, 
        #24243e 70%,
        #1a1a2e 100%
      );
    }
    
    /* Starfield effect */
    .stars {
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(2px 2px at 20px 30px, #eee, transparent),
        radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
        radial-gradient(1px 1px at 90px 40px, #fff, transparent),
        radial-gradient(2px 2px at 160px 120px, rgba(255,255,255,0.9), transparent),
        radial-gradient(1px 1px at 230px 80px, #ddd, transparent),
        radial-gradient(2px 2px at 300px 150px, #fff, transparent),
        radial-gradient(1px 1px at 50px 180px, rgba(255,255,255,0.7), transparent),
        radial-gradient(2px 2px at 180px 220px, #eee, transparent);
      background-repeat: repeat;
      background-size: 350px 250px;
      animation: twinkle 5s ease-in-out infinite alternate;
    }
    
    @keyframes twinkle {
      0% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* Castle glow */
    .castle-glow {
      filter: drop-shadow(0 0 20px rgba(236, 201, 75, 0.5));
    }
    
    /* Enemy glow */
    .enemy-glow {
      filter: drop-shadow(0 0 10px currentColor);
    }
    
    /* Input styling */
    .magic-input {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
      border: 2px solid rgba(139, 92, 246, 0.5);
      box-shadow: 0 0 20px rgba(139, 92, 246, 0.3), inset 0 0 20px rgba(139, 92, 246, 0.1);
    }
    
    .magic-input:focus {
      outline: none;
      border-color: rgba(167, 139, 250, 0.8);
      box-shadow: 0 0 30px rgba(139, 92, 246, 0.5), inset 0 0 30px rgba(139, 92, 246, 0.2);
    }
    
    /* Button hover effects */
    .magic-btn {
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    
    .magic-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .magic-btn:hover::before {
      left: 100%;
    }
    
    /* Word bubble */
    .word-bubble {
      background: linear-gradient(135deg, rgba(30, 27, 75, 0.95), rgba(49, 46, 129, 0.95));
      border: 2px solid rgba(167, 139, 250, 0.6);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }
    
    /* Health hearts */
    .heart {
      filter: drop-shadow(0 0 5px rgba(239, 68, 68, 0.5));
    }
    
    /* Spell effect */
    .spell-effect {
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    
    // ==================== CONSTANTS ====================
    const MUSIC_BASE_URL = '../assets/audio/spell-siege/music/';
    
    const MUSIC_TRACKS = {
      menu: 'Main Menu Theme.wav',
      early: 'Gameplay - Early Waves 1-3.wav',
      mid: 'Gameplay - Mid Waves 4-7.wav',
      final: 'Gameplay - Final Waves.wav',
      boss: 'Boss Encounter.wav',
      victory: 'Victory Fanfare.wav',
      gameover: 'Game Over.wav'
    };
    
    const DEFAULT_WORDS = [
      'castle', 'dragon', 'knight', 'wizard', 'magic', 'shield', 'sword', 'tower',
      'spell', 'brave', 'quest', 'kingdom', 'crown', 'throne', 'battle', 'victory',
      'armor', 'potion', 'scroll', 'ancient', 'crystal', 'shadow', 'flame', 'frost',
      'hero', 'prince', 'queen', 'guard', 'bridge', 'moat', 'wall', 'gate'
    ];
    
    // Liam's default spelling words (contractions) - lowercase for matching
    const LIAM_DEFAULT_WORDS = [
      "won't", "aren't", "haven't", "he'd", "hasn't", "doesn't",
      "we'd", "hadn't", "weren't", "they'd", "i'm", "shouldn't",
      "they're", "i'd", "wouldn't", "should've", "would've", "couldn't"
    ];
    
    const DIFFICULTY_SETTINGS = {
      liam: {
        name: "Liam Mode",
        emoji: "ü¶Å",
        description: "Contractions words, slower pace",
        baseSpeed: 0.25,
        spawnInterval: 4500,
        maxEnemies: 3,
        typingGrace: true,
        startingHealth: 6
      },
      emma: {
        name: "Emma Mode",
        emoji: "ü¶ã",
        description: "Faster pace, more challenge",
        baseSpeed: 0.4,
        spawnInterval: 3000,
        maxEnemies: 5,
        typingGrace: false,
        startingHealth: 5
      }
    };
    
    const ENEMY_TYPES = {
      basic: { color: '#ef4444', hits: 1, coins: 10, emoji: 'üëπ', name: 'Goblin' },
      armored: { color: '#6366f1', hits: 2, coins: 25, emoji: 'üõ°Ô∏è', name: 'Knight' },
      boss: { color: '#9333ea', hits: 3, coins: 50, emoji: 'üëæ', name: 'Demon' }
    };
    
    const UPGRADES = {
      spellPower: { name: '‚öîÔ∏è Spell Power', cost: 50, maxLevel: 3, description: '+1 damage per hit' },
      slowField: { name: '‚ùÑÔ∏è Slow Field', cost: 75, maxLevel: 2, description: 'Enemies move slower' },
      shield: { name: 'üõ°Ô∏è Shield', cost: 100, maxLevel: 1, description: 'Block one hit' },
      castleRepair: { name: 'üíñ Repair', cost: 60, maxLevel: 99, description: 'Restore 1 heart' }
    };
    
    // ==================== AUDIO MANAGER ====================
    class AudioManager {
      constructor() {
        this.musicPlayers = {};
        this.currentMusic = null;
        this.musicVolume = 0.4;
        this.sfxVolume = 0.6;
        this.musicEnabled = true;
        this.sfxEnabled = true;
        this.toneStarted = false;
        this.musicPreloaded = false;
        this.synths = {};
      }
      
      async initTone() {
        if (this.toneStarted) return;
        try {
          await Tone.start();
          this.toneStarted = true;
          
          // Create synths for different sounds
          this.synths.spell = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
          }).toDestination();
          
          this.synths.hit = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 4,
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
          }).toDestination();
          
          this.synths.damage = new Tone.MetalSynth({
            frequency: 150,
            envelope: { attack: 0.001, decay: 0.3, release: 0.1 },
            harmonicity: 3.1,
            modulationIndex: 16,
            resonance: 2000,
            octaves: 1.5
          }).toDestination();
          
          this.synths.combo = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'triangle' },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 }
          }).toDestination();
          
        } catch (e) {
          console.warn('Tone.js init failed:', e);
        }
      }
      
      preloadMusic() {
        // Only preload once to avoid duplicate audio players
        if (this.musicPreloaded) return;
        this.musicPreloaded = true;
        
        Object.entries(MUSIC_TRACKS).forEach(([key, filename]) => {
          const audio = new Audio(MUSIC_BASE_URL + filename);
          audio.preload = 'auto';
          audio.loop = !['victory', 'gameover'].includes(key);
          audio.volume = this.musicVolume;
          this.musicPlayers[key] = audio;
        });
      }
      
      playMusic(track) {
        if (!this.musicEnabled) return;
        
        // Stop current music
        if (this.currentMusic && this.musicPlayers[this.currentMusic]) {
          this.musicPlayers[this.currentMusic].pause();
          this.musicPlayers[this.currentMusic].currentTime = 0;
        }
        
        // Play new track
        if (this.musicPlayers[track]) {
          this.musicPlayers[track].currentTime = 0;
          this.musicPlayers[track].volume = this.musicVolume;
          this.musicPlayers[track].play().catch(() => {});
          this.currentMusic = track;
        }
      }
      
      stopMusic() {
        if (this.currentMusic && this.musicPlayers[this.currentMusic]) {
          this.musicPlayers[this.currentMusic].pause();
          this.musicPlayers[this.currentMusic].currentTime = 0;
        }
        this.currentMusic = null;
      }
      
      pauseMusic() {
        if (this.currentMusic && this.musicPlayers[this.currentMusic]) {
          this.musicPlayers[this.currentMusic].pause();
        }
      }
      
      resumeMusic() {
        if (this.musicEnabled && this.currentMusic && this.musicPlayers[this.currentMusic]) {
          this.musicPlayers[this.currentMusic].play().catch(() => {});
        }
      }
      
      setMusicEnabled(enabled) {
        this.musicEnabled = enabled;
        if (!enabled) {
          this.pauseMusic();
        } else if (this.currentMusic) {
          this.resumeMusic();
        }
      }
      
      setSfxEnabled(enabled) {
        this.sfxEnabled = enabled;
      }
      
      playSpellCast() {
        if (!this.sfxEnabled || !this.toneStarted) return;
        try {
          this.synths.spell.triggerAttackRelease('C5', '8n', undefined, this.sfxVolume);
          setTimeout(() => {
            this.synths.spell.triggerAttackRelease('E5', '16n', undefined, this.sfxVolume * 0.7);
          }, 50);
        } catch (e) {}
      }
      
      playEnemyDefeat() {
        if (!this.sfxEnabled || !this.toneStarted) return;
        try {
          this.synths.hit.triggerAttackRelease('C2', '8n', undefined, this.sfxVolume);
        } catch (e) {}
      }
      
      playCastleDamage() {
        if (!this.sfxEnabled || !this.toneStarted) return;
        try {
          this.synths.damage.triggerAttackRelease('C2', '8n', undefined, this.sfxVolume * 0.5);
        } catch (e) {}
      }
      
      playCombo(comboCount) {
        if (!this.sfxEnabled || !this.toneStarted) return;
        try {
          const notes = ['C4', 'E4', 'G4', 'C5'];
          const note = notes[Math.min(Math.floor(comboCount / 5) - 1, notes.length - 1)];
          this.synths.combo.triggerAttackRelease([note, notes[Math.min(notes.indexOf(note) + 2, 3)]], '8n', undefined, this.sfxVolume * 0.7);
        } catch (e) {}
      }
      
      playBossSpawn() {
        if (!this.sfxEnabled || !this.toneStarted) return;
        try {
          this.synths.hit.triggerAttackRelease('E1', '2n', undefined, this.sfxVolume * 0.8);
        } catch (e) {}
      }
      
      playWaveComplete() {
        if (!this.sfxEnabled || !this.toneStarted) return;
        try {
          const notes = ['C4', 'E4', 'G4', 'C5'];
          notes.forEach((note, i) => {
            setTimeout(() => {
              this.synths.combo.triggerAttackRelease(note, '8n', undefined, this.sfxVolume);
            }, i * 100);
          });
        } catch (e) {}
      }
    }
    
    const audioManager = new AudioManager();
    
    // ==================== SPEECH SYNTHESIS ====================
    const speakWord = (word) => {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.rate = 0.85;
        utterance.pitch = 1.1;
        window.speechSynthesis.speak(utterance);
      }
    };
    
    // ==================== MAIN GAME COMPONENT ====================
    function SpellSiege() {
      // Game states
      const [gameState, setGameState] = useState('menu'); // menu, setup, playing, paused, gameover, victory
      const [difficulty, setDifficulty] = useState(null);
      const [words, setWords] = useState(DEFAULT_WORDS);
      const [customWordsInput, setCustomWordsInput] = useState('');
      
      // Game data
      const [wave, setWave] = useState(1);
      const [enemies, setEnemies] = useState([]);
      const [castleHealth, setCastleHealth] = useState(5);
      const [maxHealth, setMaxHealth] = useState(5);
      const [coins, setCoins] = useState(0);
      const [combo, setCombo] = useState(0);
      const [maxCombo, setMaxCombo] = useState(0);
      const [typedWord, setTypedWord] = useState('');
      const [targetEnemy, setTargetEnemy] = useState(null);
      const [spellEffects, setSpellEffects] = useState([]);
      const [announcements, setAnnouncements] = useState([]);
      const [shakeScreen, setShakeScreen] = useState(false);
      
      // Upgrades
      const [upgrades, setUpgrades] = useState({
        spellPower: 0,
        slowField: 0,
        shield: 0,
        castleRepair: 0
      });
      const [hasShield, setHasShield] = useState(false);
      
      // Stats
      const [wordsTyped, setWordsTyped] = useState(0);
      const [mistakes, setMistakes] = useState(0);
      const [enemiesDefeated, setEnemiesDefeated] = useState(0);
      const [waveEnemiesRemaining, setWaveEnemiesRemaining] = useState(0);
      const [missedWords, setMissedWords] = useState([]);
      
      // Audio state
      const [musicEnabled, setMusicEnabled] = useState(true);
      const [sfxEnabled, setSfxEnabled] = useState(true);
      
      // Refs
      const gameLoopRef = useRef(null);
      const spawnTimerRef = useRef(null);
      const inputRef = useRef(null);
      const enemyIdCounter = useRef(0);
      const waveEnemiesSpawned = useRef(0);
      
      // Initialize audio on first interaction
      const initAudio = useCallback(async () => {
        await audioManager.initTone();
        audioManager.preloadMusic();
      }, []);
      
      // Get music track for current wave
      const getMusicTrackForWave = useCallback((w) => {
        if (w <= 3) return 'early';
        if (w <= 7) return 'mid';
        return 'final';
      }, []);
      
      // Add announcement
      const addAnnouncement = useCallback((text, type = 'info') => {
        const id = Date.now();
        setAnnouncements(prev => [...prev, { id, text, type }]);
        setTimeout(() => {
          setAnnouncements(prev => prev.filter(a => a.id !== id));
        }, 2000);
      }, []);
      
      // Create spell effect
      const createSpellEffect = useCallback((x, y, color) => {
        const id = Date.now() + Math.random();
        setSpellEffects(prev => [...prev, { id, x, y, color }]);
        setTimeout(() => {
          setSpellEffects(prev => prev.filter(e => e.id !== id));
        }, 400);
      }, []);
      
      // Spawn enemy
      const spawnEnemy = useCallback(() => {
        if (!difficulty) return;
        
        const settings = DIFFICULTY_SETTINGS[difficulty];
        if (enemies.length >= settings.maxEnemies) return;
        
        const totalEnemiesForWave = 5 + wave * 2;
        if (waveEnemiesSpawned.current >= totalEnemiesForWave) return;
        
        // Determine enemy type based on wave
        let type = 'basic';
        const roll = Math.random();
        
        if (wave >= 3 && roll < 0.15 + (wave * 0.02)) {
          type = 'armored';
        }
        if (wave >= 5 && waveEnemiesSpawned.current === totalEnemiesForWave - 1) {
          // Last enemy of wave 5+ is a boss
          type = 'boss';
          audioManager.playBossSpawn();
          addAnnouncement('üî• BOSS INCOMING! üî•', 'boss');
        }
        
        // Pick a word
        const availableWords = words.filter(w => !enemies.some(e => e.word === w));
        if (availableWords.length === 0) return;
        
        const word = availableWords[Math.floor(Math.random() * availableWords.length)];
        
        // Simple random positioning
        const enemy = {
          id: ++enemyIdCounter.current,
          type,
          word,
          x: 5 + Math.random() * 10, // Start 5-15% from left
          y: 15 + Math.random() * 55, // Random Y between 15-70%
          hits: ENEMY_TYPES[type].hits,
          speed: settings.baseSpeed * (1 - upgrades.slowField * 0.15) * (1 + wave * 0.05)
        };
        
        setEnemies(prev => [...prev, enemy]);
        waveEnemiesSpawned.current++;
        setWaveEnemiesRemaining(totalEnemiesForWave - waveEnemiesSpawned.current + enemies.length + 1);
        speakWord(word);
      }, [difficulty, enemies, wave, words, upgrades.slowField, addAnnouncement]);
      
      // Game loop
      useEffect(() => {
        if (gameState !== 'playing') return;
        
        const loop = setInterval(() => {
          setEnemies(prev => {
            const updated = prev.map(enemy => ({
              ...enemy,
              x: enemy.x + enemy.speed * 0.15
            }));
            
            // Check for enemies reaching castle (85% mark)
            const reachedCastle = updated.filter(e => e.x >= 85);
            const remaining = updated.filter(e => e.x < 85);
            
            if (reachedCastle.length > 0) {
              reachedCastle.forEach(e => {
                setMissedWords(mw => [...mw, e.word]);
              });
              
              setCastleHealth(h => {
                let damage = reachedCastle.length;
                let newHealth = h;
                
                // Check shield
                if (hasShield && damage > 0) {
                  setHasShield(false);
                  damage--;
                  addAnnouncement('üõ°Ô∏è Shield blocked!', 'shield');
                }
                
                if (damage > 0) {
                  newHealth = Math.max(0, h - damage);
                  audioManager.playCastleDamage();
                  setShakeScreen(true);
                  setTimeout(() => setShakeScreen(false), 500);
                  addAnnouncement(`üíî -${damage} Heart${damage > 1 ? 's' : ''}!`, 'damage');
                  setCombo(0);
                }
                
                return newHealth;
              });
            }
            
            return remaining;
          });
        }, 50);
        
        gameLoopRef.current = loop;
        return () => clearInterval(loop);
      }, [gameState, hasShield, addAnnouncement]);
      
      // Enemy spawning
      useEffect(() => {
        if (gameState !== 'playing' || !difficulty) return;
        
        const settings = DIFFICULTY_SETTINGS[difficulty];
        const spawn = setInterval(spawnEnemy, settings.spawnInterval);
        spawnTimerRef.current = spawn;
        
        // Initial spawn
        setTimeout(spawnEnemy, 500);
        
        return () => clearInterval(spawn);
      }, [gameState, difficulty, spawnEnemy]);
      
      // Check for wave completion
      useEffect(() => {
        if (gameState !== 'playing') return;
        
        const totalEnemiesForWave = 5 + wave * 2;
        
        if (waveEnemiesSpawned.current >= totalEnemiesForWave && enemies.length === 0) {
          // Wave complete!
          if (wave >= 10) {
            // Victory!
            setGameState('victory');
            audioManager.stopMusic();
            audioManager.playMusic('victory');
          } else {
            // Next wave
            audioManager.playWaveComplete();
            addAnnouncement(`‚ú® Wave ${wave} Complete! ‚ú®`, 'wave');
            
            setTimeout(() => {
              setWave(w => w + 1);
              waveEnemiesSpawned.current = 0;
              
              // Change music if needed
              const newTrack = getMusicTrackForWave(wave + 1);
              const currentTrack = getMusicTrackForWave(wave);
              if (newTrack !== currentTrack) {
                audioManager.playMusic(newTrack);
              }
            }, 1500);
          }
        }
        
        setWaveEnemiesRemaining(Math.max(0, totalEnemiesForWave - waveEnemiesSpawned.current) + enemies.length);
      }, [enemies.length, wave, gameState, addAnnouncement, getMusicTrackForWave]);
      
      // Check for game over
      useEffect(() => {
        if (castleHealth <= 0 && gameState === 'playing') {
          setGameState('gameover');
          audioManager.stopMusic();
          audioManager.playMusic('gameover');
        }
      }, [castleHealth, gameState]);
      
      // Handle word completion
      const handleWordComplete = useCallback((completedWord) => {
        const matchingEnemies = enemies.filter(e => e.word === completedWord);
        if (matchingEnemies.length === 0) return false;
        
        // Target closest to castle
        const target = matchingEnemies.sort((a, b) => b.x - a.x)[0];
        const damage = 1 + upgrades.spellPower;
        const newHits = target.hits - damage;
        
        createSpellEffect(target.x, target.y, ENEMY_TYPES[target.type].color);
        audioManager.playSpellCast();
        
        if (newHits <= 0) {
          // Defeated!
          const comboBonus = Math.floor(combo / 3) * 5;
          const coinReward = ENEMY_TYPES[target.type].coins + comboBonus;
          
          setEnemies(prev => prev.filter(e => e.id !== target.id));
          setCoins(prev => prev + coinReward);
          setEnemiesDefeated(d => d + 1);
          setWordsTyped(w => w + 1);
          audioManager.playEnemyDefeat();
          
          setCombo(c => {
            const newCombo = c + 1;
            setMaxCombo(m => Math.max(m, newCombo));
            if (newCombo > 0 && newCombo % 5 === 0) {
              addAnnouncement(`üî• ${newCombo}x Combo!`, 'combo');
              audioManager.playCombo(newCombo);
            }
            return newCombo;
          });
        } else {
          // Damaged but not defeated
          setEnemies(prev => prev.map(e =>
            e.id === target.id ? { ...e, hits: newHits } : e
          ));
          addAnnouncement('‚öîÔ∏è Armor cracked!', 'hit');
          audioManager.playSpellCast();
        }
        
        return true;
      }, [enemies, upgrades.spellPower, combo, createSpellEffect, addAnnouncement]);
      
      // Handle input change
      const handleInputChange = useCallback((e) => {
        // Normalize smart quotes to straight apostrophe, then filter
        const val = e.target.value
          .toLowerCase()
          .replace(/[''`]/g, "'") // Convert smart quotes to straight apostrophe
          .replace(/[^a-z']/g, '');
        setTypedWord(val);
        
        // Auto-target matching enemy
        const matchingEnemies = enemies.filter(en => en.word.startsWith(val));
        if (matchingEnemies.length > 0) {
          setTargetEnemy(matchingEnemies.sort((a, b) => b.x - a.x)[0].id);
        } else {
          setTargetEnemy(null);
        }
        
        // Check for complete word match
        if (val.length > 0 && handleWordComplete(val)) {
          setTypedWord('');
          setTargetEnemy(null);
        } else if (val.length > 0 && matchingEnemies.length === 0) {
          // No matching enemies - mistake
          if (!DIFFICULTY_SETTINGS[difficulty]?.typingGrace) {
            setMistakes(m => m + 1);
            setCombo(0);
          }
          setTypedWord('');
        }
      }, [enemies, difficulty, handleWordComplete]);
      
      // Handle key press
      const handleKeyDown = useCallback((e) => {
        if (e.key === 'Escape' && gameState === 'playing') {
          setGameState('paused');
          audioManager.pauseMusic();
        } else if (e.key === 'Enter' && gameState === 'playing') {
          e.preventDefault();
          if (typedWord && handleWordComplete(typedWord)) {
            setTypedWord('');
            setTargetEnemy(null);
          }
        }
      }, [gameState, typedWord, handleWordComplete]);
      
      // Focus input when playing
      useEffect(() => {
        if (gameState === 'playing' && inputRef.current) {
          inputRef.current.focus();
        }
      }, [gameState, enemies]);
      
      // Buy upgrade
      const buyUpgrade = useCallback((key) => {
        const upgrade = UPGRADES[key];
        if (coins < upgrade.cost) return;
        if (key !== 'castleRepair' && upgrades[key] >= upgrade.maxLevel) return;
        
        setCoins(c => c - upgrade.cost);
        
        if (key === 'castleRepair') {
          setCastleHealth(h => Math.min(maxHealth, h + 1));
          addAnnouncement('üíñ +1 Heart!', 'heal');
        } else if (key === 'shield') {
          setHasShield(true);
          setUpgrades(u => ({ ...u, [key]: u[key] + 1 }));
          addAnnouncement('üõ°Ô∏è Shield activated!', 'shield');
        } else {
          setUpgrades(u => ({ ...u, [key]: u[key] + 1 }));
        }
      }, [coins, upgrades, maxHealth, addAnnouncement]);
      
      // Start game
      const startGame = useCallback(() => {
        if (!difficulty) return;
        
        initAudio().then(() => {
          const settings = DIFFICULTY_SETTINGS[difficulty];
          
          // Parse custom words or use defaults based on difficulty
          let gameWords = difficulty === 'liam' ? LIAM_DEFAULT_WORDS : DEFAULT_WORDS;
          if (customWordsInput.trim()) {
            const custom = customWordsInput
              .toLowerCase()
              .split(/[\s,]+/)
              .map(w => w.trim())
              .filter(w => w.length >= 2 && /^[a-z']+$/.test(w));
            if (custom.length >= 5) {
              gameWords = custom;
            }
          }
          
          setWords(gameWords);
          setWave(1);
          setEnemies([]);
          setCastleHealth(settings.startingHealth);
          setMaxHealth(settings.startingHealth);
          setCoins(0);
          setCombo(0);
          setMaxCombo(0);
          setTypedWord('');
          setTargetEnemy(null);
          setWordsTyped(0);
          setMistakes(0);
          setEnemiesDefeated(0);
          setMissedWords([]);
          setUpgrades({ spellPower: 0, slowField: 0, shield: 0, castleRepair: 0 });
          setHasShield(false);
          waveEnemiesSpawned.current = 0;
          
          setGameState('playing');
          audioManager.playMusic('early');
        });
      }, [difficulty, customWordsInput, initAudio]);
      
      // Resume game
      const resumeGame = useCallback(() => {
        setGameState('playing');
        audioManager.resumeMusic();
        inputRef.current?.focus();
      }, []);
      
      // Quit to menu
      const quitToMenu = useCallback(() => {
        audioManager.stopMusic();
        setGameState('menu');
        setDifficulty(null);
        audioManager.playMusic('menu');
      }, []);
      
      // Toggle audio
      const toggleMusic = useCallback(() => {
        setMusicEnabled(e => {
          audioManager.setMusicEnabled(!e);
          return !e;
        });
      }, []);
      
      const toggleSfx = useCallback(() => {
        setSfxEnabled(e => {
          audioManager.setSfxEnabled(!e);
          return !e;
        });
      }, []);
      
      // Play menu music on mount
      useEffect(() => {
        initAudio().then(() => {
          audioManager.playMusic('menu');
        });
      }, [initAudio]);
      
      // Calculate accuracy
      const accuracy = wordsTyped > 0 
        ? Math.round((wordsTyped / (wordsTyped + mistakes)) * 100) 
        : 100;
      
      // ==================== RENDER ====================
      return (
        <div 
          className={`w-full h-screen game-bg overflow-hidden relative ${shakeScreen ? 'animate-shake' : ''}`}
          onKeyDown={handleKeyDown}
        >
          {/* Stars background */}
          <div className="stars" />
          
          {/* ==================== MENU SCREEN ==================== */}
          {gameState === 'menu' && (
            <div className="absolute inset-0 flex flex-col items-center justify-center z-20">
              <div className="text-center animate-float">
                <h1 className="font-title text-6xl md:text-8xl text-amber-400 mb-2 tracking-wider"
                    style={{ textShadow: '0 0 30px rgba(251, 191, 36, 0.5), 0 4px 0 #92400e' }}>
                  SPELL SIEGE
                </h1>
                <p className="font-game text-xl text-purple-300 mb-12">
                  ‚öîÔ∏è Tower Defense Spelling Adventure ‚öîÔ∏è
                </p>
              </div>
              
              <div className="flex flex-col gap-4">
                <button
                  onClick={() => { initAudio(); setGameState('setup'); }}
                  className="magic-btn px-12 py-4 bg-gradient-to-r from-purple-600 to-indigo-600 
                           text-white font-game text-2xl rounded-xl shadow-lg hover:scale-105
                           border-2 border-purple-400/50"
                >
                  üè∞ Start Quest
                </button>
                
                <div className="flex gap-4 justify-center mt-4">
                  <button
                    onClick={toggleMusic}
                    className={`px-4 py-2 rounded-lg font-game text-sm transition-all
                              ${musicEnabled ? 'bg-green-600 text-white' : 'bg-slate-700 text-slate-400'}`}
                  >
                    üéµ Music {musicEnabled ? 'ON' : 'OFF'}
                  </button>
                  <button
                    onClick={toggleSfx}
                    className={`px-4 py-2 rounded-lg font-game text-sm transition-all
                              ${sfxEnabled ? 'bg-green-600 text-white' : 'bg-slate-700 text-slate-400'}`}
                  >
                    üîä SFX {sfxEnabled ? 'ON' : 'OFF'}
                  </button>
                </div>
              </div>
              
              <div className="absolute bottom-8 text-purple-400/60 font-game text-sm">
                Made with ‚ù§Ô∏è for Emma & Liam
              </div>
            </div>
          )}
          
          {/* ==================== SETUP SCREEN ==================== */}
          {gameState === 'setup' && (
            <div className="absolute inset-0 flex flex-col items-center justify-center z-20 p-4">
              <div className="bg-slate-900/90 rounded-2xl p-8 max-w-lg w-full border-2 border-purple-500/30
                            shadow-[0_0_50px_rgba(139,92,246,0.3)]">
                <h2 className="font-title text-3xl text-amber-400 text-center mb-6">Choose Your Hero</h2>
                
                {/* Difficulty selection */}
                <div className="flex gap-4 mb-6">
                  {Object.entries(DIFFICULTY_SETTINGS).map(([key, settings]) => (
                    <button
                      key={key}
                      onClick={() => setDifficulty(key)}
                      className={`flex-1 p-4 rounded-xl border-2 transition-all font-game
                                ${difficulty === key 
                                  ? 'bg-purple-600 border-purple-400 scale-105' 
                                  : 'bg-slate-800 border-slate-600 hover:border-purple-500'}`}
                    >
                      <div className="text-4xl mb-2">{settings.emoji}</div>
                      <div className="text-lg text-white">{settings.name}</div>
                      <div className="text-xs text-slate-400">{settings.description}</div>
                    </button>
                  ))}
                </div>
                
                {/* Custom words */}
                <div className="mb-6">
                  <label className="block text-purple-300 font-game mb-2 text-sm">
                    üìù Custom Spelling Words (optional)
                  </label>
                  <textarea
                    value={customWordsInput}
                    onChange={(e) => setCustomWordsInput(e.target.value)}
                    placeholder="Paste weekly spelling words here, separated by spaces or commas..."
                    className="w-full h-24 bg-slate-800 border-2 border-slate-600 rounded-lg p-3
                             text-white font-game text-sm resize-none focus:border-purple-500 focus:outline-none"
                  />
                  <p className="text-slate-500 text-xs mt-1">
                    Minimum 5 words, letters only. Leave blank for default fantasy words.
                  </p>
                </div>
                
                {/* Start button */}
                <div className="flex gap-4">
                  <button
                    onClick={quitToMenu}
                    className="px-6 py-3 bg-slate-700 text-slate-300 font-game rounded-lg
                             hover:bg-slate-600 transition-all"
                  >
                    ‚Üê Back
                  </button>
                  <button
                    onClick={startGame}
                    disabled={!difficulty}
                    className={`flex-1 py-3 font-game text-lg rounded-lg transition-all
                              ${difficulty 
                                ? 'bg-gradient-to-r from-green-600 to-emerald-600 text-white hover:scale-105' 
                                : 'bg-slate-700 text-slate-500 cursor-not-allowed'}`}
                  >
                    ‚öîÔ∏è Begin Battle!
                  </button>
                </div>
              </div>
            </div>
          )}
          
          {/* ==================== GAME SCREEN ==================== */}
          {(gameState === 'playing' || gameState === 'paused') && (
            <>
              {/* HUD - Top */}
              <div className="absolute top-0 left-0 right-0 p-4 flex justify-between items-start z-10">
                {/* Left: Wave & Enemies */}
                <div className="bg-slate-900/80 rounded-xl p-3 border border-purple-500/30">
                  <div className="font-title text-amber-400 text-xl">Wave {wave}/10</div>
                  <div className="font-game text-purple-300 text-sm">
                    {waveEnemiesRemaining} enemies left
                  </div>
                </div>
                
                {/* Center: Health */}
                <div className="bg-slate-900/80 rounded-xl px-4 py-2 border border-purple-500/30 flex items-center gap-2">
                  {[...Array(maxHealth)].map((_, i) => (
                    <span 
                      key={i} 
                      className={`text-2xl heart transition-all ${i < castleHealth ? '' : 'opacity-30 grayscale'}`}
                    >
                      {i < castleHealth ? '‚ù§Ô∏è' : 'üñ§'}
                    </span>
                  ))}
                  {hasShield && <span className="text-2xl ml-2">üõ°Ô∏è</span>}
                </div>
                
                {/* Right: Coins & Combo */}
                <div className="bg-slate-900/80 rounded-xl p-3 border border-purple-500/30 text-right">
                  <div className="font-game text-amber-400 text-xl">üí∞ {coins}</div>
                  {combo > 0 && (
                    <div className={`font-game text-orange-400 text-sm ${combo % 5 === 0 ? 'animate-combo-pop' : ''}`}>
                      üî• {combo}x Combo!
                    </div>
                  )}
                </div>
              </div>
              
              {/* Audio controls */}
              <div className="absolute top-4 left-1/2 -translate-x-1/2 flex gap-2 z-10" style={{ marginTop: '60px' }}>
                <button
                  onClick={toggleMusic}
                  className={`w-10 h-10 rounded-full flex items-center justify-center text-lg
                            ${musicEnabled ? 'bg-green-600' : 'bg-slate-700'}`}
                >
                  {musicEnabled ? 'üéµ' : 'üîá'}
                </button>
                <button
                  onClick={toggleSfx}
                  className={`w-10 h-10 rounded-full flex items-center justify-center text-lg
                            ${sfxEnabled ? 'bg-green-600' : 'bg-slate-700'}`}
                >
                  {sfxEnabled ? 'üîä' : 'üîà'}
                </button>
              </div>
              
              {/* Game field */}
              <div className="absolute inset-0 overflow-hidden" onClick={() => inputRef.current?.focus()}>
                {/* Castle (right side) */}
                <div className="absolute right-4 top-1/2 -translate-y-1/2 castle-glow">
                  <div className="text-8xl">üè∞</div>
                </div>
                
                {/* Enemies */}
                {enemies.map(enemy => (
                  <div
                    key={enemy.id}
                    className="absolute transition-all duration-75 animate-enemy-spawn"
                    style={{
                      left: `${enemy.x}%`,
                      top: `${enemy.y}%`,
                      transform: 'translate(-50%, -50%)'
                    }}
                  >
                    {/* Word bubble */}
                    <div className={`word-bubble rounded-lg px-3 py-1 mb-2 text-center
                                  ${targetEnemy === enemy.id ? 'ring-2 ring-amber-400' : ''}`}>
                      <div className="flex items-center gap-2">
                        <span className="font-game text-white text-lg tracking-wide">
                          {enemy.word.split('').map((char, i) => (
                            <span 
                              key={i}
                              className={i < typedWord.length && enemy.word.startsWith(typedWord) 
                                ? 'text-green-400' 
                                : 'text-white'}
                            >
                              {char}
                            </span>
                          ))}
                        </span>
                        <button
                          onClick={(e) => { e.stopPropagation(); speakWord(enemy.word); }}
                          className="text-purple-400 hover:text-purple-300 text-sm"
                        >
                          üîä
                        </button>
                      </div>
                      {enemy.hits > 1 && (
                        <div className="text-xs text-purple-400">
                          {'üíú'.repeat(enemy.hits)}
                        </div>
                      )}
                    </div>
                    
                    {/* Enemy sprite */}
                    <div 
                      className="text-5xl text-center enemy-glow"
                      style={{ color: ENEMY_TYPES[enemy.type].color }}
                    >
                      {ENEMY_TYPES[enemy.type].emoji}
                    </div>
                  </div>
                ))}
                
                {/* Spell effects */}
                {spellEffects.map(effect => (
                  <div
                    key={effect.id}
                    className="absolute spell-effect animate-spell-fire"
                    style={{
                      left: `${effect.x}%`,
                      top: `${effect.y}%`,
                      transform: 'translate(-50%, -50%)'
                    }}
                  >
                    <div className="text-6xl">‚ú®</div>
                  </div>
                ))}
                
                {/* Announcements */}
                <div className="absolute top-1/3 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2">
                  {announcements.map(a => (
                    <div
                      key={a.id}
                      className={`font-title text-2xl px-6 py-2 rounded-xl animate-combo-pop
                                ${a.type === 'combo' ? 'text-orange-400 bg-orange-900/50' :
                                  a.type === 'wave' ? 'text-green-400 bg-green-900/50' :
                                  a.type === 'boss' ? 'text-purple-400 bg-purple-900/50' :
                                  a.type === 'damage' ? 'text-red-400 bg-red-900/50' :
                                  a.type === 'heal' ? 'text-pink-400 bg-pink-900/50' :
                                  'text-blue-400 bg-blue-900/50'}`}
                    >
                      {a.text}
                    </div>
                  ))}
                </div>
              </div>
              
              {/* Bottom: Input & Upgrades */}
              <div className="absolute bottom-0 left-0 right-0 p-4 bg-slate-900/90 border-t border-purple-500/30">
                {/* Typing input */}
                <div className="text-center mb-4">
                  <input
                    ref={inputRef}
                    type="text"
                    value={typedWord}
                    onChange={handleInputChange}
                    onKeyDown={handleKeyDown}
                    autoFocus
                    autoComplete="off"
                    autoCorrect="off"
                    autoCapitalize="off"
                    spellCheck={false}
                    placeholder="Type a word..."
                    className="magic-input w-72 md:w-96 px-6 py-3 rounded-xl text-center
                             font-game text-xl text-white placeholder-purple-400/50"
                  />
                </div>
                
                {/* Upgrades */}
                <div className="flex justify-center gap-2 flex-wrap">
                  {Object.entries(UPGRADES).map(([key, upgrade]) => {
                    const currentLevel = upgrades[key];
                    const maxed = key !== 'castleRepair' && currentLevel >= upgrade.maxLevel;
                    const canBuy = coins >= upgrade.cost && !maxed;
                    const cantRepair = key === 'castleRepair' && castleHealth >= maxHealth;
                    
                    return (
                      <button
                        key={key}
                        onClick={() => buyUpgrade(key)}
                        disabled={!canBuy || cantRepair}
                        title={upgrade.description}
                        className={`px-3 py-2 rounded-lg font-game text-sm transition-all
                                  ${maxed || cantRepair
                                    ? 'bg-green-700/50 text-green-300 cursor-default'
                                    : canBuy
                                      ? 'bg-purple-600 hover:bg-purple-500 text-white hover:scale-105'
                                      : 'bg-slate-700 text-slate-500 cursor-not-allowed'}`}
                      >
                        <div>{upgrade.name}</div>
                        <div className="text-xs">
                          {maxed ? '‚úì MAX' : cantRepair ? '‚úì FULL' : `üí∞${upgrade.cost}`}
                          {key !== 'castleRepair' && key !== 'shield' && !maxed && ` (${currentLevel}/${upgrade.maxLevel})`}
                        </div>
                      </button>
                    );
                  })}
                </div>
                
                <p className="text-center text-slate-500 text-sm mt-2 font-game">
                  Press ESC to pause
                </p>
              </div>
              
              {/* PAUSED Overlay */}
              {gameState === 'paused' && (
                <div className="absolute inset-0 bg-black/70 flex items-center justify-center z-30">
                  <div className="bg-slate-900 rounded-2xl p-8 border-2 border-purple-500/50 text-center">
                    <h2 className="font-title text-4xl text-amber-400 mb-6">‚è∏Ô∏è PAUSED</h2>
                    <div className="flex flex-col gap-4">
                      <button
                        onClick={resumeGame}
                        className="px-8 py-3 bg-green-600 text-white font-game text-lg rounded-lg
                                 hover:bg-green-500 transition-all"
                      >
                        ‚ñ∂Ô∏è Resume
                      </button>
                      <button
                        onClick={quitToMenu}
                        className="px-8 py-3 bg-slate-700 text-slate-300 font-game rounded-lg
                                 hover:bg-slate-600 transition-all"
                      >
                        üè† Quit to Menu
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </>
          )}
          
          {/* ==================== GAME OVER SCREEN ==================== */}
          {gameState === 'gameover' && (
            <div className="absolute inset-0 bg-black/80 flex items-center justify-center z-30">
              <div className="bg-slate-900 rounded-2xl p-8 max-w-md w-full mx-4 border-2 border-red-500/50 text-center">
                <h2 className="font-title text-4xl text-red-400 mb-2">üíî GAME OVER</h2>
                <p className="font-game text-slate-400 mb-6">The castle has fallen...</p>
                
                <div className="bg-slate-800 rounded-xl p-4 mb-6 text-left font-game">
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <div className="text-slate-400">Wave Reached:</div>
                    <div className="text-white text-right">{wave}</div>
                    <div className="text-slate-400">Enemies Defeated:</div>
                    <div className="text-white text-right">{enemiesDefeated}</div>
                    <div className="text-slate-400">Words Spelled:</div>
                    <div className="text-white text-right">{wordsTyped}</div>
                    <div className="text-slate-400">Accuracy:</div>
                    <div className="text-white text-right">{accuracy}%</div>
                    <div className="text-slate-400">Best Combo:</div>
                    <div className="text-white text-right">{maxCombo}x</div>
                  </div>
                  
                  {missedWords.length > 0 && (
                    <div className="mt-4 pt-4 border-t border-slate-700">
                      <div className="text-red-400 mb-2">üìù Words to Practice:</div>
                      <div className="flex flex-wrap gap-2">
                        {[...new Set(missedWords)].slice(0, 10).map((word, i) => (
                          <span key={i} className="px-2 py-1 bg-red-900/30 text-red-300 rounded text-xs">
                            {word}
                          </span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
                
                <div className="flex gap-4">
                  <button
                    onClick={quitToMenu}
                    className="flex-1 py-3 bg-slate-700 text-slate-300 font-game rounded-lg
                             hover:bg-slate-600 transition-all"
                  >
                    üè† Menu
                  </button>
                  <button
                    onClick={startGame}
                    className="flex-1 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 
                             text-white font-game rounded-lg hover:scale-105 transition-all"
                  >
                    üîÑ Try Again
                  </button>
                </div>
              </div>
            </div>
          )}
          
          {/* ==================== VICTORY SCREEN ==================== */}
          {gameState === 'victory' && (
            <div className="absolute inset-0 bg-black/70 flex items-center justify-center z-30">
              <div className="bg-slate-900 rounded-2xl p-8 max-w-md w-full mx-4 border-2 border-amber-500/50 text-center">
                <h2 className="font-title text-4xl text-amber-400 mb-2 animate-float">üèÜ VICTORY! üèÜ</h2>
                <p className="font-game text-green-400 mb-6">The kingdom is saved!</p>
                
                <div className="bg-slate-800 rounded-xl p-4 mb-6 text-left font-game">
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <div className="text-slate-400">Enemies Defeated:</div>
                    <div className="text-amber-400 text-right">{enemiesDefeated}</div>
                    <div className="text-slate-400">Words Spelled:</div>
                    <div className="text-amber-400 text-right">{wordsTyped}</div>
                    <div className="text-slate-400">Accuracy:</div>
                    <div className="text-amber-400 text-right">{accuracy}%</div>
                    <div className="text-slate-400">Best Combo:</div>
                    <div className="text-amber-400 text-right">{maxCombo}x</div>
                    <div className="text-slate-400">Total Coins:</div>
                    <div className="text-amber-400 text-right">üí∞ {coins}</div>
                    <div className="text-slate-400">Hearts Remaining:</div>
                    <div className="text-amber-400 text-right">{'‚ù§Ô∏è'.repeat(castleHealth)}</div>
                  </div>
                </div>
                
                <div className="flex gap-4">
                  <button
                    onClick={quitToMenu}
                    className="flex-1 py-3 bg-slate-700 text-slate-300 font-game rounded-lg
                             hover:bg-slate-600 transition-all"
                  >
                    üè† Menu
                  </button>
                  <button
                    onClick={startGame}
                    className="flex-1 py-3 bg-gradient-to-r from-amber-600 to-yellow-600 
                             text-white font-game rounded-lg hover:scale-105 transition-all"
                  >
                    üîÑ Play Again
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }
    
    // Render the app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SpellSiege />);
  </script>
</body>
</html>
